# from celery import shared_task
# from backend.celery_app import app
# import fitz
# import os
# from django.conf import settings
# import requests
# import json
# from .models import Exam, Question, Option
# import logging

# logger = logging.getLogger(__name__)


# @shared_task
# def process_exam_document(exam_id):
#     """Process an exam document to extract or generate questions"""
#     try:
#         exam = Exam.objects.get(id=exam_id)

#         # Update status
#         exam.processing_status = "processing"
#         exam.save()

#         # Extract text from PDF
#         file_path = os.path.join(settings.MEDIA_ROOT, exam.pdf_file.name)
#         text_content = extract_text_from_file(file_path)

#         if not text_content:
#             raise Exception("Failed to extract text from document")

#         # Generate questions using AI
#         questions = generate_questions_from_text(text_content, exam.mcq_options_count)

#         # Save questions to database
#         save_questions_to_database(exam, questions)

#         # Update exam status
#         exam.is_processed = True
#         exam.processing_status = "completed"
#         exam.save()

#         return True

#     except Exception as e:
#         logger.error(f"Error processing exam {exam_id}: {str(e)}")

#         # Update exam status
#         try:
#             exam = Exam.objects.get(id=exam_id)
#             exam.processing_status = "failed"
#             exam.save()
#         except:
#             pass

#         return False


# def extract_text_from_file(file_path):
#     """Extract text from PDF or text file"""
#     try:
#         file_ext = os.path.splitext(file_path)[1].lower()

#         if file_ext == ".pdf":
#             # Extract text from PDF using PyMuPDF
#             text = ""
#             with fitz.open(file_path) as pdf:
#                 for page in pdf:
#                     text += page.get_text()
#             return text

#         elif file_ext in [".txt", ".text"]:
#             # Read text file
#             with open(file_path, "r", encoding="utf-8") as f:
#                 return f.read()

#         else:
#             logger.error(f"Unsupported file type: {file_ext}")
#             return None

#     except Exception as e:
#         logger.error(f"Error extracting text: {str(e)}")
#         return None


# def generate_questions_from_text(text_content, options_count):
#     """Generate MCQ questions from text content using AI"""
#     try:
#         # Example using OpenAI API - replace with your preferred AI service
#         api_key = settings.OPENAI_API_KEY

#         prompt = f"""
#         Generate MCQ questions based on the following content.
#         Each question should have {options_count} options with exactly one correct answer.

#         Format the response as a JSON array with the following structure:
#         [
#             {{
#                 "question": "Question text here",
#                 "options": [
#                     {{"text": "Option 1", "correct": false}},
#                     {{"text": "Option 2", "correct": false}},
#                     {{"text": "Option 3", "correct": true}},
#                     {{"text": "Option 4", "correct": false}}
#                 ],
#                 "explanation": "Explanation for the correct answer"
#             }}
#         ]

#         Content:
#         {text_content[:4000]}  # Limit content to avoid token limits
#         """

#         response = requests.post(
#             "https://api.openai.com/v1/chat/completions",
#             headers={
#                 "Authorization": f"Bearer {api_key}",
#                 "Content-Type": "application/json",
#             },
#             json={
#                 "model": "gpt-4",
#                 "messages": [{"role": "user", "content": prompt}],
#                 "temperature": 0.7,
#             },
#         )

#         response_data = response.json()

#         if "choices" not in response_data:
#             logger.error(f"API Error: {response_data}")
#             return []

#         content = response_data["choices"][0]["message"]["content"]

#         # Parse the JSON response
#         questions = json.loads(content)
#         return questions

#     except Exception as e:
#         logger.error(f"Error generating questions: {str(e)}")
#         return []


# def save_questions_to_database(exam, questions_data):
#     """Save generated questions to database"""
#     try:
#         for q_data in questions_data:
#             # Create question
#             question = Question.objects.create(
#                 exam=exam,
#                 question_text=q_data["question"],
#                 explanation=q_data.get("explanation", ""),
#                 from_pdf=False,  # Generated by AI
#             )

#             # Create options
#             for opt_data in q_data["options"]:
#                 Option.objects.create(
#                     question=question,
#                     option_text=opt_data["text"],
#                     is_correct=opt_data["correct"],
#                 )

#     except Exception as e:
#         logger.error(f"Error saving questions: {str(e)}")
#         raise
